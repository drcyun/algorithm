# 贪心和动态规划

## 贪心算法

***

### 简介

有很多经典的应用，比如霍夫曼编码，Prim 和 Kruskal 最小生成树算法、还有 Dijkstra单源最短路径算法。

#### 关键标记

期望值和限制值

#### 贪心算法解决问题的步骤

1. 第一步，当我们看见这类问题的时候，首先要联想到贪心算法
2. 第二步，我们尝试看下这个问题是否可以用贪心算法解决
3. 第三步，我们举几个例子看下贪心算法产生的结果是否是最优的；

***

### 贪心算法实战

#### 分糖果

##### 问题：

我们有m个糖果和n和孩子。现在我们要把糖果分给这些孩子吃，但是糖果少，孩子多（m < n），所以糖果只能分配给一部分孩子。
每个糖果的大小不等，这m个糖果的大小分别是s1，s2，s3，......,sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子对糖果大小的需求的时候，孩子才得到满足。假设这n个孩子对糖果带下的需求分别是g1，g2，g3，......，gn。
问题是，如何分配糖果，能尽可能满足最多数量的孩子？

``` 
1. 分别对糖果的大小和孩子对糖果的需求大小进行排序
2. 从糖果最大（最小）的开始将该糖果分配给满足条件对糖果需求最大（最小）的孩子
3. 依次类推，直到找不到满足条件的糖果或者没有糖果再进行分配了
4. 这样就能尽可能多的满足孩子
```

#### 钱币找零

##### 问题：

这个问题在我们的日常生活中更加普遍。假设我们有1元、2元、5元、10元、20元、50元、100元、这些面额的纸币，它们的张数分别是c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付K元，最少要用多少张纸币呢？

```
1. 使用K对100进行整除，得到的结果为需要的100面额张数。并且的到一个余数K'
2. 使用K'对50进行整除，得到的结果为需要的50面额张数。并且得到一个余数K''
3. 依次类推，分别对20，10，......，1进行整除。当余数为0是循环结束。
4. 最少需要用的纸币数量为需要的各张纸币的数量的总和。
```

#### 区间覆盖

##### 问题：

假设我们有n个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2，r2]，......，[ln, rn]。我们从这n个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？

```
1. 将区间的起始端点进行排序
2. 在起始端点不重合的情况下，从区间大小最小的开始，尽可能选择区间大小小的区间
3. 这样就能选出最多不相交的区间
```

***

### 贪心算法-霍夫曼编码

#### 简介

霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码视图痛这种不等长的编码方法，来进一步增加压缩的效率。

***

### 总结

贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型。只要这一步搞定之后，贪心算法的编码一般都很简单。贪心算法解决问题的正确性虽然很多时候都看起来是显而易见的，但是要严谨地证明算法能够得到最优解，并不是件容易的事。
